// ===== DEFINICIONES DE COLORES =====
#ifndef FOREGROUND_WHITE
#define FOREGROUND_WHITE (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE)
#endif

#ifndef FOREGROUND_YELLOW
#define FOREGROUND_YELLOW (FOREGROUND_RED | FOREGROUND_GREEN)
#endif

#ifndef FOREGROUND_CYAN
#define FOREGROUND_CYAN (FOREGROUND_GREEN | FOREGROUND_BLUE)
#endif

#include <windows.h>
#include <stdio.h>
#include <string>

static bool g_ShowRecvPackets = false;
static bool g_ShowSendPackets = true;

// ===== CONSOLA =====
static BOOL g_ConsoleCreated = FALSE;
static FILE *g_LogFile = NULL;

void SetConsoleColor(WORD color)
{
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hConsole)
        SetConsoleTextAttribute(hConsole, color);
}

void CreateConsole()
{
    if (g_ConsoleCreated)
        return;

    for (int i = 0; i < 3; i++)
    {
        if (AllocConsole())
        {
            g_ConsoleCreated = TRUE;
            break;
        }
        Sleep(100);
    }

    if (!g_ConsoleCreated)
        return;

    SetConsoleTitleA("HTLauncher Traffic Monitor - Complete");

    FILE *pCout;
    FILE *pCerr;
    if (freopen_s(&pCout, "CONOUT$", "w", stdout) == 0 &&
        freopen_s(&pCerr, "CONOUT$", "w", stderr) == 0)
    {
        printf("=== HTLauncher Traffic Monitor - Complete Analysis ===\n");
        printf("Analizando todos los tipos de paquetes...\n\n");
        fflush(stdout);
    }
}


unsigned char pKeyWord[1024][2] = {
    // Índices 0-255
    {0x28, 0x3D}, {0x03, 0xD2}, {0x9A, 0x6A}, {0x6F, 0xA1}, {0xD3, 0xA1}, {0xC9, 0x7C}, {0x73, 0x7F}, {0x73, 0xB6}, 
    {0xC9, 0x79}, {0x73, 0x05}, {0x97, 0x0B}, {0x23, 0x05}, {0x19, 0x0F}, {0x69, 0x0C}, {0x14, 0x78}, {0x19, 0x69}, 
    {0x87, 0x0C}, {0x16, 0x0C}, {0x0F, 0x0F}, {0x23, 0x81}, {0x73, 0xD3}, {0x70, 0x2A}, {0x85, 0x67}, {0x22, 0x90}, 
    {0xC9, 0x71}, {0x23, 0x7B}, {0x0F, 0x7E}, {0x70, 0x79}, {0x84, 0xCA}, {0x87, 0x81}, {0xAB, 0x7D}, {0x87, 0x7C}, 
    {0x23, 0xBE}, {0x0B, 0x7D}, {0x0F, 0x65}, {0x87, 0x0B}, {0xB9, 0x8C}, {0x73, 0x70}, {0x7F, 0x0F}, {0x15, 0xB2}, 
    {0x82, 0x6E}, {0x91, 0x7C}, {0x87, 0xBB}, {0x19, 0x79}, {0xFF, 0x05}, {0x16, 0x69}, {0xCD, 0x6F}, {0xEB, 0x79}, 
    {0xEB, 0x19}, {0x05, 0x2F}, {0xC0, 0x5F}, {0x19, 0x41}, {0xEB, 0x91}, {0x71, 0x7B}, {0xA7, 0x4B}, {0x32, 0x7D}, 
    {0xA4, 0x7D}, {0x87, 0x19}, {0x21, 0xC2}, {0x87, 0x16}, {0xEB, 0x7A}, {0xE8, 0x7D}, {0x23, 0x7D}, {0x19, 0x7D}, 
    {0xD7, 0x17}, {0x23, 0x0C}, {0x14, 0x78}, {0x19, 0x7D}, {0x87, 0x7D}, {0x23, 0x7B}, {0x8B, 0xC3}, {0xEB, 0x7A}, 
    {0x87, 0x7D}, {0xD4, 0x83}, {0x16, 0xDD}, {0xEB, 0x78}, {0x10, 0x7E}, {0x7D, 0x7D}, {0x88, 0x19}, {0x87, 0xF5}, 
    {0x87, 0x7D}, {0xD7, 0xE1}, {0x9B, 0x87}, {0xEB, 0x9B}, {0xCD, 0x7B}, {0x23, 0x6C}, {0x83, 0x7F}, {0xEB, 0x14}, 
    {0xD7, 0x7D}, {0x1F, 0x73}, {0x37, 0x7D}, {0xCB, 0x0F}, {0x23, 0x16}, {0xCD, 0x19}, {0x73, 0xB9}, {0x8D, 0x7D}, 
    {0x7B, 0x7D}, {0xDE, 0x73}, {0x83, 0x7A}, {0x84, 0x7D}, {0x1F, 0x7D}, {0x23, 0x7D}, {0x1F, 0x7D}, {0x87, 0x7D}, 
    {0x87, 0x7D}, {0x73, 0x67}, {0xEB, 0xE1}, {0x23, 0x7D}, {0x87, 0x0F}, {0xD7, 0x7D}, {0x66, 0x7D}, {0xEB, 0x7D}, 
    {0xEB, 0x7D}, {0xE7, 0x7D}, {0x87, 0x79}, {0xEB, 0x98}, {0xF5, 0x66}, {0xEB, 0x80}, {0x87, 0x1A}, {0x87, 0xE1}, 
    {0x16, 0x6F}, {0xD1, 0x79}, {0x83, 0x9B}, {0x19, 0x85}, {0x8D, 0x7B}, {0x0F, 0x79}, {0xDF, 0x79}, {0xEB, 0x6B}, 
    {0x87, 0x7D}, {0x15, 0x7C}, {0x2D, 0x7D}, {0xCD, 0xDD}, {0x85, 0x73}, {0xD7, 0x86}, {0x0F, 0x79}, {0xE8, 0x79}, 
    {0x05, 0x7D}, {0xD7, 0xCD}, {0x19, 0xE1}, {0x87, 0xDD}, {0x18, 0x8F}, {0x05, 0x7D}, {0x0F, 0x7A}, {0xE7, 0x73}, 
    {0x23, 0x9B}, {0x0B, 0x0F}, {0x85, 0x7C}, {0x69, 0x0F}, {0x87, 0x80}, {0x87, 0x79}, {0x84, 0x87}, {0x37, 0xD7}, 
    {0x22, 0x79}, {0x8D, 0x91}, {0x0B, 0x73}, {0x4B, 0x19}, {0x19, 0x69}, {0x91, 0x23}, {0x87, 0x81}, {0xD7, 0xD6}, 
    {0x23, 0xE1}, {0x4B, 0x83}, {0x85, 0xA1}, {0xD7, 0x79}, {0x21, 0x7D}, {0xE6, 0x69}, {0x23, 0x7E}, {0xAE, 0x7C}, 
    {0x0F, 0xE1}, {0x0B, 0x6A}, {0x15, 0x79}, {0x9B, 0x7D}, {0x02, 0x91}, {0x0F, 0x7B}, {0x86, 0x71}, {0xDD, 0x2D}, 
    {0x87, 0x6F}, {0xC9, 0x79}, {0xD7, 0x7C}, {0x23, 0x1C}, {0x23, 0x4B}, {0x05, 0x7F}, {0x05, 0x79}, {0x37, 0x68}, 
    {0x5F, 0x79}, {0x19, 0x7D}, {0x87, 0x7A}, {0x21, 0x7D}, {0x23, 0x19}, {0x87, 0x95}, {0x7D, 0x7D}, {0x7D, 0x78}, 
    {0x69, 0x7D}, {0x87, 0x7D}, {0x73, 0x7D}, {0x87, 0x7D}, {0x87, 0x7C}, {0x79, 0x91}, {0xEB, 0x7A}, {0x23, 0xAF}, 
    {0x87, 0x23}, {0xEB, 0x10}, {0xCD, 0xDF}, {0x87, 0x86}, {0x87, 0xA5}, {0x87, 0x7C}, {0x73, 0x7E}, {0xED, 0x7D}, 
    {0xD7, 0x7D}, {0xEB, 0x7D}, {0x73, 0x7D}, {0xD7, 0x7D}, {0xE1, 0x7A}, {0x68, 0x79}, {0xD6, 0x7E}, {0xEB, 0x98}, 
    {0x19, 0x79}, {0xCD, 0x7D}, {0x19, 0x7A}, {0xEB, 0x23}, {0x9B, 0x6F}, {0x23, 0x7C}, {0x0F, 0x7B}, {0xD7, 0x7A}, 
    {0x7D, 0x80}, {0xE7, 0x85}, {0x2D, 0x7A}, {0x23, 0x7D}, {0x87, 0x6A}, {0xCD, 0xA5}, {0x0F, 0x7D}, {0x18, 0x7F}, 
    {0xAF, 0x79}, {0x37, 0x7C}, {0x0F, 0x79}, {0xCD, 0x7D}, {0xCD, 0x7A}, {0x21, 0x7D}, {0x19, 0x19}, {0xE6, 0x95}, 
    {0x19, 0x0E}, {0x23, 0x79}, {0x16, 0x7D}, {0x69, 0x7D}, {0xCD, 0x7A}, {0x69, 0x79}, {0xEB, 0x7D}, {0xEB, 0x7D}, 
    {0xCD, 0x7A}, {0xEB, 0x37}, {0xCD, 0x73}, {0xCD, 0x87}, {0xE7, 0xCF}, {0x18, 0x6C}, {0x7C, 0x91}, {0xEB, 0x7D}, 

    // Índices 256-511
    {0x04, 0x06}, {0x03, 0xD2}, {0x9A, 0x7E}, {0x6F, 0xA1}, {0xD3, 0xA1}, {0xC9, 0x7C}, {0x73, 0x7F}, {0x73, 0xB6}, 
    {0xC9, 0x79}, {0x73, 0x05}, {0x0F, 0x0B}, {0x23, 0x05}, {0x19, 0x0F}, {0x05, 0x0C}, {0xCD, 0x78}, {0x19, 0x69}, 
    {0x87, 0x0C}, {0x16, 0x0C}, {0x0F, 0x0F}, {0x23, 0x81}, {0x0F, 0xD3}, {0x70, 0x2A}, {0x85, 0x67}, {0x22, 0x90}, 
    {0xD3, 0x71}, {0x23, 0x7B}, {0x0F, 0x7E}, {0x70, 0x79}, {0x84, 0xCA}, {0x87, 0x81}, {0xAB, 0x7D}, {0x87, 0x7C}, 
    {0x23, 0xBE}, {0x0B, 0x7D}, {0x69, 0x65}, {0x87, 0x0B}, {0xB9, 0x8C}, {0x73, 0x70}, {0x7F, 0x0F}, {0x15, 0xB2}, 
    {0x82, 0x6E}, {0x91, 0x7C}, {0x0F, 0xBB}, {0xEB, 0x79}, {0xFF, 0x05}, {0x16, 0x69}, {0xCD, 0x6F}, {0x19, 0x79}, 
    {0x19, 0x19}, {0x05, 0x2F}, {0xC0, 0x5F}, {0x19, 0x41}, {0xEB, 0x91}, {0x71, 0x7B}, {0xA7, 0x4B}, {0x32, 0x7D}, 
    {0xA4, 0x7D}, {0x0D, 0x19}, {0x21, 0xC2}, {0x87, 0x16}, {0xEB, 0x7A}, {0xE8, 0x7D}, {0x23, 0x7D}, {0xD7, 0x7D}, 
    {0xD7, 0x17}, {0x23, 0x80}, {0xCD, 0x78}, {0x19, 0x7D}, {0x87, 0x7D}, {0x23, 0x7B}, {0x8B, 0xC3}, {0xEB, 0x7A}, 
    {0x87, 0x7D}, {0x16, 0x83}, {0x16, 0xDD}, {0xEB, 0x78}, {0x10, 0x7E}, {0x7D, 0x7D}, {0x88, 0x19}, {0x87, 0xF5}, 
    {0x87, 0x7D}, {0xD7, 0xE1}, {0x9B, 0x87}, {0xEB, 0x9B}, {0xCD, 0x7B}, {0x23, 0x6C}, {0x83, 0x7F}, {0xEB, 0x14}, 
    {0xD7, 0x7D}, {0x1F, 0x73}, {0x37, 0x7D}, {0xCB, 0x0F}, {0x23, 0x16}, {0xCD, 0x19}, {0x73, 0xB9}, {0x8D, 0x7D}, 
    {0x0D, 0x7D}, {0xDE, 0x73}, {0x83, 0x7A}, {0x84, 0x7D}, {0x1F, 0x7D}, {0x23, 0x7D}, {0x1F, 0x0F}, {0x87, 0x7D}, 
    {0x87, 0x7D}, {0x73, 0x67}, {0xEB, 0xE1}, {0x23, 0x7D}, {0x87, 0x0F}, {0xD7, 0x7D}, {0x66, 0x7D}, {0xEB, 0x7D}, 
    {0xEB, 0x7D}, {0xE7, 0x7D}, {0x87, 0x79}, {0xEB, 0x98}, {0xF5, 0x66}, {0xEB, 0x80}, {0x87, 0x1A}, {0x87, 0xE1}, 
    {0x16, 0x6F}, {0xD1, 0x79}, {0x83, 0x9B}, {0xE1, 0x85}, {0x8D, 0x7B}, {0x0F, 0x79}, {0xDF, 0x79}, {0xEB, 0x6B}, 
    {0x87, 0x7D}, {0x15, 0x7C}, {0x2D, 0x7D}, {0xCD, 0xDD}, {0x85, 0x73}, {0xD7, 0x86}, {0x0F, 0x79}, {0xE8, 0x79}, 
    {0x05, 0x7D}, {0xD7, 0xCD}, {0x19, 0xE1}, {0x87, 0xDD}, {0x18, 0x8F}, {0x05, 0x0F}, {0x87, 0x7A}, {0xE7, 0x73}, 
    {0x23, 0x9B}, {0x0B, 0x87}, {0x85, 0x7C}, {0x69, 0x0F}, {0x87, 0x80}, {0x87, 0x79}, {0x84, 0x87}, {0x37, 0xD7}, 
    {0x22, 0x79}, {0x8D, 0x91}, {0x0B, 0x73}, {0x4B, 0x19}, {0xEB, 0x69}, {0x91, 0x23}, {0x87, 0x81}, {0xD7, 0xD6}, 
    {0x23, 0xE1}, {0x4B, 0x83}, {0x85, 0xA1}, {0xD7, 0x79}, {0x21, 0x7D}, {0xE6, 0x69}, {0x23, 0x7E}, {0xAE, 0x7C}, 
    {0x0F, 0xE1}, {0x0B, 0x6A}, {0x15, 0x79}, {0x9B, 0x7D}, {0x02, 0x91}, {0x0F, 0x7B}, {0x86, 0x71}, {0xDD, 0x2D}, 
    {0x87, 0x6F}, {0xC9, 0x79}, {0xD7, 0x7C}, {0x23, 0x1C}, {0x23, 0x4B}, {0x05, 0x7F}, {0x05, 0x79}, {0x37, 0x68}, 
    {0x5F, 0x79}, {0xCD, 0x7D}, {0x87, 0x7A}, {0x21, 0x0F}, {0x23, 0x19}, {0x87, 0x95}, {0x7D, 0x7D}, {0x7D, 0x78}, 
    {0x69, 0x7D}, {0x87, 0x7D}, {0x73, 0x7D}, {0x87, 0x7D}, {0x87, 0x7C}, {0x79, 0x91}, {0xEB, 0x7A}, {0x23, 0xAF}, 
    {0x87, 0x23}, {0xEB, 0x10}, {0xCD, 0xDF}, {0x87, 0x86}, {0x87, 0xA5}, {0x87, 0x7C}, {0x73, 0x7E}, {0xED, 0x7D}, 
    {0xD7, 0x7D}, {0xEB, 0x7D}, {0x73, 0x7D}, {0xD7, 0x7D}, {0xE1, 0x7A}, {0x68, 0x79}, {0xD6, 0x7E}, {0x19, 0x98}, 
    {0x19, 0x79}, {0xCD, 0x7D}, {0xE1, 0x7A}, {0xEB, 0x23}, {0x9B, 0x6F}, {0x23, 0x7C}, {0x87, 0x7B}, {0xD7, 0x7A}, 
    {0x7D, 0x80}, {0xE7, 0x85}, {0x2D, 0x7A}, {0x23, 0x7D}, {0x87, 0x6A}, {0xCD, 0xA5}, {0x0F, 0x7D}, {0x18, 0x7F}, 
    {0xAF, 0x79}, {0x37, 0x7C}, {0x69, 0x79}, {0xCD, 0x7D}, {0xCD, 0x7A}, {0x21, 0x7D}, {0xEB, 0x19}, {0xE6, 0x95}, 
    {0x19, 0x0E}, {0x23, 0x79}, {0x16, 0x7D}, {0x69, 0x7D}, {0xCD, 0x0C}, {0x69, 0x79}, {0xEB, 0x7D}, {0xEB, 0x7D}, 
    {0xCD, 0x7A}, {0xEB, 0x37}, {0xCD, 0x73}, {0xCD, 0x87}, {0xE7, 0xCF}, {0x18, 0x6C}, {0x7C, 0x91}, {0xEB, 0x7D}, 

    // Índices 512-767
    {0x04, 0x06}, {0x03, 0xD2}, {0x9A, 0x7E}, {0x6F, 0xA1}, {0xD3, 0xA1}, {0xC9, 0x7C}, {0x73, 0x7F}, {0x73, 0xB6}, 
    {0xC9, 0x79}, {0x73, 0x05}, {0x0F, 0x0B}, {0x23, 0x05}, {0x19, 0x0F}, {0x05, 0x0C}, {0xCD, 0x78}, {0x19, 0x69}, 
    {0x87, 0x0C}, {0x16, 0x0C}, {0x0F, 0x0F}, {0x23, 0x81}, {0x73, 0xD3}, {0x70, 0x2A}, {0x85, 0x67}, {0x22, 0x90}, 
    {0x15, 0x71}, {0x23, 0x7B}, {0x0F, 0x7E}, {0x70, 0x79}, {0x84, 0xCA}, {0x87, 0x81}, {0xAB, 0x7D}, {0x87, 0x7C}, 
    {0x23, 0xBE}, {0x0B, 0x7D}, {0x69, 0x65}, {0x87, 0x0B}, {0xB9, 0x8C}, {0x73, 0x70}, {0x7F, 0x0F}, {0x15, 0xB2}, 
    {0x82, 0x6E}, {0x91, 0x7C}, {0x87, 0xBB}, {0x19, 0x79}, {0xFF, 0x05}, {0x16, 0x69}, {0xCD, 0x6F}, {0x19, 0x79}, 
    {0xEB, 0x19}, {0x05, 0x2F}, {0xC0, 0x5F}, {0x19, 0x41}, {0x23, 0x91}, {0x71, 0x0D}, {0xA7, 0x4B}, {0x32, 0x7D}, 
    {0xA4, 0x7D}, {0x87, 0x19}, {0x21, 0xC2}, {0x87, 0x16}, {0xEB, 0x7A}, {0xE8, 0x7D}, {0x23, 0x7D}, {0xD7, 0x7D}, 
    {0xD7, 0x17}, {0x23, 0x80}, {0xCD, 0x78}, {0x19, 0x7D}, {0x0F, 0x7D}, {0x23, 0x7B}, {0x8B, 0xC3}, {0x19, 0x7A}, 
    {0x87, 0x7D}, {0xD4, 0x83}, {0x16, 0xDD}, {0xEB, 0x78}, {0x10, 0x7E}, {0x7D, 0x7D}, {0x88, 0x19}, {0x87, 0xF5}, 
    {0x87, 0x7D}, {0xD7, 0xE1}, {0x9B, 0x87}, {0xEB, 0x9B}, {0xCD, 0x7B}, {0x23, 0x6C}, {0x83, 0x7F}, {0xEB, 0x14}, 
    {0xD7, 0x7D}, {0x1F, 0x73}, {0x37, 0x7D}, {0xCB, 0x0F}, {0x23, 0x16}, {0xCD, 0x19}, {0x73, 0xB9}, {0x8D, 0x7D}, 
    {0x7B, 0x7D}, {0xDE, 0x73}, {0x83, 0x7A}, {0x84, 0x7D}, {0x1F, 0x7D}, {0x23, 0x7D}, {0x1F, 0x7D}, {0x87, 0x7D}, 
    {0x87, 0x7D}, {0x73, 0x67}, {0xEB, 0xE1}, {0x23, 0x7D}, {0x87, 0x0F}, {0xD7, 0x7D}, {0x66, 0x0F}, {0xEB, 0x7D}, 
    {0xEB, 0x7D}, {0xE7, 0x7D}, {0x87, 0x79}, {0xEB, 0x98}, {0xF5, 0x66}, {0xEB, 0x80}, {0x87, 0x1A}, {0x87, 0xE1}, 
    {0x16, 0x6F}, {0xD1, 0x79}, {0x83, 0x9B}, {0xE1, 0x85}, {0x8D, 0x7B}, {0x0F, 0x79}, {0xDF, 0x79}, {0xEB, 0x6B}, 
    {0x87, 0x7D}, {0x15, 0x7C}, {0x2D, 0x7D}, {0xCD, 0xDD}, {0x85, 0x73}, {0xD7, 0x86}, {0x0F, 0x79}, {0xE8, 0x79}, 
    {0xCD, 0x7D}, {0xD7, 0xCD}, {0x19, 0x19}, {0x87, 0xDD}, {0x18, 0x8F}, {0x05, 0x7D}, {0x87, 0x7A}, {0xE7, 0x73}, 
    {0x23, 0x9B}, {0x0B, 0x87}, {0x85, 0x7C}, {0x69, 0x0F}, {0x87, 0x80}, {0x87, 0x79}, {0x84, 0x87}, {0x37, 0xD7}, 
    {0x22, 0x0B}, {0x8D, 0x91}, {0x0B, 0x73}, {0x4B, 0x19}, {0xEB, 0x0F}, {0x91, 0x23}, {0x87, 0x81}, {0xD7, 0xD6}, 
    {0x23, 0xE1}, {0x4B, 0x83}, {0x85, 0xA1}, {0xD7, 0x79}, {0x21, 0x7D}, {0xE6, 0x69}, {0x23, 0x7E}, {0xAE, 0x7C}, 
    {0x0F, 0xE1}, {0x0B, 0x6A}, {0x15, 0x79}, {0x9B, 0x7D}, {0x02, 0x0F}, {0x0F, 0x7B}, {0x86, 0x71}, {0xDD, 0x2D}, 
    {0x87, 0x6F}, {0xC9, 0x79}, {0xD7, 0x7C}, {0x23, 0x1C}, {0x23, 0x4B}, {0x05, 0x7F}, {0x05, 0x79}, {0x37, 0x68}, 
    {0x5F, 0x79}, {0xCD, 0x7D}, {0x87, 0x7A}, {0x21, 0x7D}, {0x23, 0x19}, {0x87, 0x95}, {0x7D, 0x7D}, {0x7D, 0x78}, 
    {0x69, 0x7D}, {0x87, 0x7D}, {0x73, 0x7D}, {0x87, 0x7D}, {0x87, 0x7C}, {0x79, 0x91}, {0xEB, 0x7A}, {0x23, 0xAF}, 
    {0x87, 0x23}, {0xEB, 0x10}, {0xCD, 0xDF}, {0x87, 0x86}, {0x87, 0xA5}, {0x87, 0x7C}, {0x73, 0x7E}, {0xED, 0x7D}, 
    {0xD7, 0x7D}, {0xEB, 0x7D}, {0x73, 0x7D}, {0xD7, 0x7D}, {0xE1, 0x7A}, {0x68, 0x79}, {0xD6, 0x7E}, {0xEB, 0x98}, 
    {0x19, 0x79}, {0xCD, 0x7D}, {0xE1, 0x7A}, {0xEB, 0x23}, {0x9B, 0x6F}, {0x23, 0x7C}, {0x87, 0x7B}, {0xD7, 0x7A}, 
    {0x7D, 0x80}, {0xE7, 0x85}, {0x2D, 0x7A}, {0x23, 0x7D}, {0x87, 0x6A}, {0xCD, 0xA5}, {0x0F, 0x7D}, {0x18, 0x7F}, 
    {0xAF, 0x79}, {0x37, 0x7C}, {0x69, 0x79}, {0x19, 0x7D}, {0xCD, 0x7A}, {0x21, 0x7D}, {0xEB, 0x19}, {0xE6, 0x95}, 
    {0x19, 0x0E}, {0x23, 0x79}, {0x16, 0x7D}, {0x69, 0x7D}, {0x19, 0x7A}, {0x69, 0x79}, {0xEB, 0x7D}, {0xEB, 0x7D}, 
    {0xCD, 0x7A}, {0xEB, 0x37}, {0xCD, 0x73}, {0xCD, 0x87}, {0xE7, 0xCF}, {0x18, 0x6C}, {0x7C, 0x91}, {0x19, 0x7D},

    // Índices 768-1023
    {0x04, 0x06}, {0x03, 0xD2}, {0x9A, 0x7E}, {0x6F, 0xA1}, {0xD3, 0xA1}, {0xC9, 0x7C}, {0x73, 0x7F}, {0x73, 0xB6}, 
    {0xC9, 0x79}, {0x73, 0x05}, {0x0F, 0x0B}, {0x23, 0x05}, {0x19, 0x0F}, {0x05, 0x0C}, {0xCD, 0x78}, {0x19, 0x69}, 
    {0x87, 0x0C}, {0x16, 0x0C}, {0x0F, 0x0F}, {0x23, 0x81}, {0x73, 0xD3}, {0x70, 0x2A}, {0x85, 0x67}, {0x22, 0x90}, 
    {0xD3, 0x71}, {0x23, 0x0D}, {0x0F, 0x7E}, {0x70, 0x79}, {0x84, 0xCA}, {0x87, 0x81}, {0xAB, 0x7D}, {0x87, 0x7C}, 
    {0x23, 0xBE}, {0x0B, 0x7D}, {0x69, 0x65}, {0x87, 0x0B}, {0xB9, 0x8C}, {0x73, 0x70}, {0x7F, 0x0F}, {0x15, 0xB2}, 
    {0x82, 0x6E}, {0x91, 0x7C}, {0x87, 0xBB}, {0xEB, 0x79}, {0xFF, 0x05}, {0x16, 0x69}, {0xCD, 0x6F}, {0xEB, 0x79}, 
    {0xEB, 0x19}, {0x05, 0x2F}, {0xC0, 0x5F}, {0x19, 0x41}, {0x19, 0x91}, {0x71, 0x7B}, {0xA7, 0x4B}, {0x32, 0x0F}, 
    {0xA4, 0x7D}, {0x87, 0x19}, {0x21, 0xC2}, {0x87, 0x16}, {0x19, 0x7A}, {0x16, 0x7D}, {0x23, 0x7D}, {0xD7, 0x7D}, 
    {0xD7, 0x17}, {0x23, 0x80}, {0xCD, 0x78}, {0x19, 0x7D}, {0x87, 0x7D}, {0x23, 0x7B}, {0x8B, 0xC3}, {0x19, 0x7A}, 
    {0x87, 0x7D}, {0xD4, 0x83}, {0x16, 0xDD}, {0xEB, 0x78}, {0x10, 0x7E}, {0x7D, 0x7D}, {0x88, 0x19}, {0x87, 0xF5}, 
    {0x87, 0x7D}, {0xD7, 0xE1}, {0x9B, 0x87}, {0xEB, 0x9B}, {0xCD, 0x7B}, {0x23, 0x6C}, {0x83, 0x7F}, {0xEB, 0x14}, 
    {0x19, 0x7D}, {0x1F, 0x73}, {0x37, 0x7D}, {0xCB, 0x0F}, {0x23, 0x16}, {0xCD, 0x19}, {0x73, 0xB9}, {0x8D, 0x7D}, 
    {0x7B, 0x7D}, {0xDE, 0x73}, {0x0D, 0x7A}, {0x84, 0x7D}, {0x1F, 0x7D}, {0x23, 0x7D}, {0x1F, 0x7D}, {0x87, 0x7D}, 
    {0x87, 0x7D}, {0x73, 0x67}, {0xEB, 0xE1}, {0x23, 0x7D}, {0x87, 0x0F}, {0xD7, 0x7D}, {0x66, 0x7D}, {0xEB, 0x7D}, 
    {0xEB, 0x7D}, {0xE7, 0x7D}, {0x87, 0x79}, {0xEB, 0x98}, {0xF5, 0x66}, {0xEB, 0x80}, {0x87, 0x1A}, {0x87, 0xE1}, 
    {0x16, 0x6F}, {0xD1, 0x79}, {0x83, 0x9B}, {0xE1, 0x85}, {0x8D, 0x7B}, {0x0F, 0x79}, {0xDF, 0x79}, {0xEB, 0x6B}, 
    {0x87, 0x7D}, {0x15, 0x7C}, {0x2D, 0x7D}, {0xCD, 0xDD}, {0x85, 0x73}, {0xD7, 0x86}, {0x0F, 0x79}, {0x16, 0x79}, 
    {0x05, 0x7D}, {0xD7, 0xCD}, {0x19, 0xE1}, {0x87, 0xDD}, {0x18, 0x8F}, {0x05, 0x7D}, {0x87, 0x7A}, {0x15, 0x73}, 
    {0x23, 0x9B}, {0x0B, 0x0F}, {0x85, 0x7C}, {0x69, 0x0F}, {0x87, 0x80}, {0x87, 0x79}, {0x84, 0x87}, {0x37, 0xD7}, 
    {0x22, 0x79}, {0x8D, 0x91}, {0x0B, 0x73}, {0x4B, 0x19}, {0xEB, 0x69}, {0x91, 0x23}, {0x87, 0x81}, {0xD7, 0xD6}, 
    {0x23, 0xE1}, {0x4B, 0x83}, {0x0D, 0xA1}, {0xD7, 0x79}, {0x21, 0x7D}, {0x14, 0x69}, {0x23, 0x7E}, {0x0E, 0x7C}, 
    {0x0F, 0xE1}, {0x0B, 0x6A}, {0x15, 0x79}, {0x0F, 0x7D}, {0x02, 0x91}, {0x0F, 0x7B}, {0x86, 0x71}, {0xDD, 0x2D}, 
    {0x87, 0x6F}, {0xC9, 0x79}, {0xD7, 0x7C}, {0x23, 0x1C}, {0x23, 0x4B}, {0x05, 0x7F}, {0x05, 0x79}, {0x37, 0x68}, 
    {0x5F, 0x79}, {0xCD, 0x7D}, {0x87, 0x7A}, {0x21, 0x7D}, {0x23, 0x19}, {0x87, 0x95}, {0x7D, 0x7D}, {0x7D, 0x78}, 
    {0x69, 0x7D}, {0x87, 0x7D}, {0x73, 0x7D}, {0x87, 0x7D}, {0x87, 0x0E}, {0x79, 0x91}, {0xEB, 0x7A}, {0x23, 0xAF}, 
    {0x87, 0x23}, {0xEB, 0x10}, {0xCD, 0xDF}, {0x87, 0x86}, {0x87, 0xA5}, {0x87, 0x7C}, {0x73, 0x7E}, {0xED, 0x7D}, 
    {0xD7, 0x7D}, {0xEB, 0x7D}, {0x73, 0x0F}, {0xD7, 0x7D}, {0xE1, 0x7A}, {0x68, 0x79}, {0xD6, 0x7E}, {0xEB, 0x98}, 
    {0x19, 0x79}, {0xCD, 0x7D}, {0x19, 0x7A}, {0xEB, 0x23}, {0x9B, 0x6F}, {0x23, 0x7C}, {0x87, 0x7B}, {0xD7, 0x7A}, 
    {0x7D, 0x80}, {0xE7, 0x85}, {0x2D, 0x7A}, {0x23, 0x7D}, {0x87, 0x6A}, {0xCD, 0xA5}, {0x0F, 0x7D}, {0x18, 0x7F}, 
    {0xAF, 0x79}, {0x37, 0x7C}, {0x69, 0x79}, {0x19, 0x7D}, {0xCD, 0x7A}, {0x21, 0x7D}, {0x19, 0x19}, {0xE6, 0x95}, 
    {0x19, 0x0E}, {0x23, 0x79}, {0x16, 0x7D}, {0x69, 0x7D}, {0x19, 0x7A}, {0x69, 0x79}, {0xEB, 0x7D}, {0x19, 0x7D}, 
    {0xCD, 0x7A}, {0xEB, 0x37}, {0xCD, 0x73}, {0xCD, 0x87}, {0xE7, 0xCF}, {0x18, 0x6C}, {0x7C, 0x91}, {0xEB, 0x7D},
};

typedef struct _HEADER
{
    WORD wType;
    WORD wSeq;
    WORD wPDULength;
    WORD wDummy;
    DWORD dwClientTick;
} HEADER;

#define INITCODE 0x1F44F321

const char *GetPacketTypeName(WORD type)
{
    switch (type)
    {
    case 0x0366: return "MOVE_REQUEST";
    case 0x9022: return "MOVE_RESPONSE";
    case 0x0367: return "STOP_MOVE";
    case 0x1001: return "LOGIN_REQUEST";
    case 0x8001: return "LOGIN_RESPONSE";
    case 0x1010: return "CHAR_SELECT";
    case 0x8010: return "CHAR_DATA";
    case 0x1002: return "CHAT_MESSAGE";
    case 0x8002: return "CHAT_BROADCAST";
    case 0x1020: return "WHISPER_SEND";
    case 0x8020: return "WHISPER_RECV";
    case 0x1004: return "ATTACK_REQUEST";
    case 0x8004: return "ATTACK_RESPONSE";
    case 0x1005: return "SKILL_USE";
    case 0x8005: return "SKILL_EFFECT";
    case 0x1030: return "ITEM_USE";
    case 0x8030: return "ITEM_UPDATE";
    case 0x1031: return "ITEM_DROP";
    case 0x8031: return "ITEM_PICKUP";
    case 0x1040: return "NPC_TALK";
    case 0x8040: return "NPC_RESPONSE";
    case 0x1041: return "SHOP_BUY";
    case 0x8041: return "SHOP_RESULT";
    case 0x1050: return "PARTY_INVITE";
    case 0x8050: return "PARTY_UPDATE";
    case 0x1060: return "TRADE_REQUEST";
    case 0x8060: return "TRADE_UPDATE";
    case 0x2001: return "PLAYER_SPAWN";
    case 0x2002: return "PLAYER_DESPAWN";
    case 0x2003: return "MONSTER_SPAWN";
    case 0x2004: return "MONSTER_DESPAWN";
    case 0x3001: return "HEALTH_UPDATE";
    case 0x3002: return "MANA_UPDATE";
    case 0x4001: return "HEARTBEAT";
    case 0x3240: return "SKILL_CAST_BUFF";
    case 0x0369: return "STATUS_UPDATE";
    case 0x1003: return "SERVER_SELECT";
    case 0x1011: return "CHAR_LIST_REQUEST";
    case 0x120A: return "ITEM_PICKUP";
    default: return "UNKNOWN";
    }
}

void WriteToLog(const char *format, ...)
{
    if (!g_LogFile)
        return;

    va_list args;
    va_start(args, format);
    vfprintf(g_LogFile, format, args);
    va_end(args);
    fflush(g_LogFile);
}

static unsigned char g_oldRecvChecksum = 0;
static unsigned char g_ucRecvSeq = 0;
static unsigned char g_oldSendChecksum = 0;
static unsigned char g_ucSendSeq = 0;
static int g_PacketCount = 0;

class SimpleHook
{
private:
    void *target;
    unsigned char original[5];
    unsigned char patch[5];
    bool installed;

public:
    SimpleHook() : target(NULL), installed(false) {}

    void Init(void *targetFunc, void *hookFunc)
    {
        target = targetFunc;
        if (target)
        {
            memcpy(original, target, 5);
            patch[0] = 0xE9;
            *(DWORD *)(patch + 1) = (DWORD)hookFunc - (DWORD)target - 5;
        }
    }

    bool Install()
    {
        if (!target || installed)
            return false;
        DWORD oldProtect;
        if (VirtualProtect(target, 5, PAGE_EXECUTE_READWRITE, &oldProtect))
        {
            memcpy(target, patch, 5);
            VirtualProtect(target, 5, oldProtect, &oldProtect);
            installed = true;
            return true;
        }
        return false;
    }

    bool Uninstall()
    {
        if (!target || !installed)
            return false;
        DWORD oldProtect;
        if (VirtualProtect(target, 5, PAGE_EXECUTE_READWRITE, &oldProtect))
        {
            memcpy(target, original, 5);
            VirtualProtect(target, 5, oldProtect, &oldProtect);
            installed = false;
            return true;
        }
        return false;
    }
};

static SimpleHook g_SendHook, g_RecvHook;
typedef int(__stdcall *SendFunc)(unsigned int, const char *, int, int);
typedef int(__stdcall *RecvFunc)(unsigned int, char *, int, int);
static SendFunc OriginalSend = NULL;
static RecvFunc OriginalRecv = NULL;

void PrintPacket(const char *direction, const char *data, int len, bool decrypted = false)
{
    SYSTEMTIME st;
    GetLocalTime(&st);

    g_PacketCount++;

    // Establecer color según dirección
    if (strcmp(direction, "SEND") == 0)
        SetConsoleColor(FOREGROUND_RED | FOREGROUND_INTENSITY);
    else
        SetConsoleColor(FOREGROUND_BLUE | FOREGROUND_INTENSITY);

    // Encabezado del paquete
    printf("\n[%02d:%02d:%02d.%03d] #%d %s", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, g_PacketCount, direction);
    WriteToLog("\n[%02d:%02d:%02d.%03d] #%d %s", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, g_PacketCount, direction);
    
    if (decrypted) {
        printf(" [DECRYPTED]");
        WriteToLog(" [DECRYPTED]");
    }
    
    printf(" (%d bytes)\n", len);
    WriteToLog(" (%d bytes)\n", len);

    // Análisis del header si está disponible
    if (len >= sizeof(HEADER))
    {
        HEADER *h = (HEADER *)data;
        printf("  Type: 0x%04X (%s), Seq: 0x%04X, Length: %d, Tick: %lu\n",
               h->wType, GetPacketTypeName(h->wType), h->wSeq, h->wPDULength, h->dwClientTick);
        WriteToLog("  Type: 0x%04X (%s), Seq: 0x%04X, Length: %d, Tick: %lu\n",
                   h->wType, GetPacketTypeName(h->wType), h->wSeq, h->wPDULength, h->dwClientTick);

        // // Datos RAW en hexadecimal
        // printf("  RAW HEX:\n    ");
        // WriteToLog("  RAW HEX:\n    ");
        for (int i = 0; i < len; i++)
        {
            if (i > 0 && i % 16 == 0) {
                printf("\n    ");
                WriteToLog("\n    ");
            }
            printf("%02X ", (unsigned char)data[i]);
            WriteToLog("%02X ", (unsigned char)data[i]);
        }
        printf("\n");
        WriteToLog("\n");

        // Análisis del payload si existe
        if (len > sizeof(HEADER))
        {
            const char *payload = data + sizeof(HEADER);
            int payloadLen = len - sizeof(HEADER);

            printf("  PAYLOAD (%d bytes):\n", payloadLen);
            WriteToLog("  PAYLOAD (%d bytes):\n", payloadLen);

            // Como bytes
            printf("    AS BYTES: ");
            WriteToLog("    AS BYTES: ");
            for (int i = 0; i < payloadLen && i < 32; i++) {
                printf("%02X ", (unsigned char)payload[i]);
                WriteToLog("%02X ", (unsigned char)payload[i]);
            }
            if (payloadLen > 32) {
                printf("...");
                WriteToLog("...");
            }
            printf("\n");
            WriteToLog("\n");

            // Como texto ASCII
            printf("    AS TEXT: ");
            WriteToLog("    AS TEXT: ");
            bool foundText = false;
            for (int i = 0; i < payloadLen; i++) {
                if (payload[i] >= 32 && payload[i] <= 126) {
                    printf("%c", payload[i]);
                    WriteToLog("%c", payload[i]);
                    foundText = true;
                } else if (foundText) {
                    printf(".");
                    WriteToLog(".");
                }
            }
            if (!foundText) {
                printf("[No ASCII text]");
                WriteToLog("[No ASCII text]");
            }
            printf("\n");
            WriteToLog("\n");

            // Análisis específico por tipo de paquete
            switch (h->wType)
            {
            // case 0x0366: // MOVE_REQUEST
            //     if (payloadLen >= 16)
            //     {
            //         DWORD *coords = (DWORD *)payload;
            //         printf("Move to X=%lu, Y=%lu, Dir=%lu, Speed=%lu",
            //                coords[1] & 0xFFFF, (coords[1] >> 16) & 0xFFFF,
            //                coords[2] & 0xFFFF, (coords[2] >> 16) & 0xFFFF);
            //         WriteToLog("Move to X=%lu, Y=%lu, Dir=%lu, Speed=%lu",
            //                    coords[1] & 0xFFFF, (coords[1] >> 16) & 0xFFFF,
            //                    coords[2] & 0xFFFF, (coords[2] >> 16) & 0xFFFF);
            //     }
            //     break;
            case 0x3240: // SKILL_CAST_BUFF
                if (payloadLen >= 4) {
                    // printf("    SKILL ANALYSIS:\n");
                    // WriteToLog("    SKILL ANALYSIS:\n");
                    
                    // DWORD *dwords = (DWORD *)payload;
                    // int dwordCount = payloadLen / 4;
                    
                    // for (int i = 0; i < dwordCount; i++) {
                    //     printf("      [%02d] = %10u (0x%08X)", i, dwords[i], dwords[i]);
                    //     WriteToLog("      [%02d] = %10u (0x%08X)", i, dwords[i], dwords[i]);
                        
                    //     if (dwords[i] == 3229) {
                    //         printf(" <-- SKILL ID 3229!");
                    //         WriteToLog(" <-- SKILL ID 3229!");
                    //     } else if (dwords[i] > 3000 && dwords[i] < 4000) {
                    //         printf(" <-- Possible skill ID");
                    //         WriteToLog(" <-- Possible skill ID");
                    //     }
                    //     printf("\n");
                    //     WriteToLog("\n");
                    // }

                                        printf("    ATTACK STRUCTURE:\n");
                    WriteToLog("    ATTACK STRUCTURE:\n");
                    
                    short skillID = *(int *)(payload + 0);
                    short casterID = *(int *)(payload + 2);
                    short targetID = *(int *)(payload + 4);
                    float x = *(float *)(payload + 8);
                    float y = *(float *)(payload + 12);
                    float z = *(float *)(payload + 16);
                    
                    printf("      SkillID: %d\n", skillID);
                    printf("      CasterID: %d\n", casterID);
                    printf("      TargetID: %d\n", targetID);
                    printf("      TargetPos: X=%.2f Y=%.2f Z=%.2f\n", x, y, z);
                    WriteToLog("      SkillID: %d\n", skillID);
                    WriteToLog("      CasterID: %d\n", casterID);
                    WriteToLog("      TargetID: %d\n", targetID);
                    WriteToLog("      TargetPos: X=%.2f Y=%.2f Z=%.2f\n", x, y, z);
                }
                break;

            // case 0x1004: // ATTACK_REQUEST
            //     if (payloadLen >= 20) {
            //         printf("    ATTACK STRUCTURE:\n");
            //         WriteToLog("    ATTACK STRUCTURE:\n");
                    
            //         short skillID = *(short *)(payload + 0);
            //         short casterID = *(short *)(payload + 2);
            //         short targetID = *(short *)(payload + 4);
            //         float x = *(float *)(payload + 8);
            //         float y = *(float *)(payload + 12);
            //         float z = *(float *)(payload + 16);
                    
            //         printf("      SkillID: %d\n", skillID);
            //         printf("      CasterID: %d\n", casterID);
            //         printf("      TargetID: %d\n", targetID);
            //         printf("      TargetPos: X=%.2f Y=%.2f Z=%.2f\n", x, y, z);
            //         WriteToLog("      SkillID: %d\n", skillID);
            //         WriteToLog("      CasterID: %d\n", casterID);
            //         WriteToLog("      TargetID: %d\n", targetID);
            //         WriteToLog("      TargetPos: X=%.2f Y=%.2f Z=%.2f\n", x, y, z);
            //     }
            //     break;
            }

            // Detectar skill 3229 en cualquier paquete descifrado
            if (decrypted && payloadLen >= 2) {
                unsigned short skillID = *(unsigned short *)payload;
                if (skillID == 3229) {
                    SetConsoleColor(FOREGROUND_YELLOW | FOREGROUND_RED | FOREGROUND_INTENSITY);
                    printf("\n*******************************************\n");
                    printf("*** ¡¡¡SKILL 3229 DETECTADO!!! ***\n");
                    printf("*** Tipo de paquete: 0x%04X ***\n", h->wType);
                    printf("*** Tamaño total: %d bytes ***\n", len);
                    printf("*******************************************\n\n");

                    WriteToLog("\n*******************************************\n");
                    WriteToLog("*** ¡¡¡SKILL 3229 DETECTADO!!! ***\n");
                    WriteToLog("*** Tipo de paquete: 0x%04X ***\n", h->wType);
                    WriteToLog("*** Tamaño total: %d bytes ***\n", len);
                    WriteToLog("*******************************************\n\n");

                    // Guardar en archivo especial
                    FILE *skillFile = fopen("skill_3229_packets.log", "a");
                    if (skillFile) {
                        fprintf(skillFile, "[%02d:%02d:%02d.%03d] Skill 3229 - Type: 0x%04X, Size: %d\n",
                                st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, h->wType, len);
                        fprintf(skillFile, "Raw packet (hex): ");
                        for (int i = 0; i < len && i < 128; i++)
                            fprintf(skillFile, "%02X ", (unsigned char)data[i]);
                        fprintf(skillFile, "\n\n");
                        fclose(skillFile);
                    }
                }
            }
        }
    }
    else
    {
        // Para paquetes sin header válido
        printf("  Raw Data: ");
        WriteToLog("  Raw Data: ");
        for (int i = 0; i < len; i++) {
            printf("%02X ", (unsigned char)data[i]);
            WriteToLog("%02X ", (unsigned char)data[i]);
        }
        printf("\n");
        WriteToLog("\n");
    }

    SetConsoleColor(FOREGROUND_WHITE);
    fflush(stdout);
}

bool DecryptSent(char *data, int size)
{
    if (size < sizeof(HEADER))
        return false;
    
    static bool first_encrypted_packet = true;
    if (first_encrypted_packet) {
        printf("*** FIRST ENCRYPTED PACKET DETECTED ***\n");
        WriteToLog("*** FIRST ENCRYPTED PACKET DETECTED ***\n");
        first_encrypted_packet = false;
    }

    char temp[2048];
    memcpy(temp, data, size);
    unsigned char checksum = *((unsigned char *)(temp + 3));

    // Arrays de valores de prueba para sincronización
    unsigned char test_checksums[] = {0, 1, checksum, (unsigned char)(checksum-1), (unsigned char)(checksum+1), 0xBF, 
                                     (unsigned char)(checksum-2), (unsigned char)(checksum+2), (unsigned char)(checksum-3), (unsigned char)(checksum+3),
                                     g_oldSendChecksum, (unsigned char)(g_oldSendChecksum+1), (unsigned char)(g_oldSendChecksum-1)};
    unsigned char test_seqs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 100,
                                g_ucSendSeq, (unsigned char)(g_ucSendSeq+1), (unsigned char)(g_ucSendSeq-1), (unsigned char)(g_ucSendSeq+2), (unsigned char)(g_ucSendSeq-2)};

    int best_diff = 255;
    int best_cs = -1;
    int best_sq = -1;
    char best_result[2048];
    unsigned char original_checksum = checksum;

    for (int cs = 0; cs < 13; cs++) {
        for (int sq = 0; sq < 25; sq++) {
            memcpy(temp, data, size);

            int KeywordFlag = test_checksums[cs] % 2;
            unsigned char calculatedSum = 0;
            int pos = test_seqs[sq];

            for (int i = sizeof(HEADER); i < size; i++, pos++) {
                int rst = pos % 1024; //
                
                unsigned char Trans = pKeyWord[rst][KeywordFlag];
                int mod = i & 0x3;

                if (mod == 0) temp[i] = temp[i] - (Trans << 2);
                if (mod == 1) temp[i] = temp[i] + (Trans >> 1);
                if (mod == 2) temp[i] = temp[i] - (Trans << 1);
                if (mod == 3) temp[i] = temp[i] + (Trans >> 2);

                calculatedSum += temp[i];
            }

            int diff = calculatedSum > original_checksum ? calculatedSum - original_checksum : original_checksum - calculatedSum;

            if (diff < best_diff) {
                best_diff = diff;
                best_cs = cs;
                best_sq = sq;
                memcpy(best_result, temp, size);
            }

            if (calculatedSum == original_checksum) {
                printf("*** FOUND PERFECT COMBINATION! checksum=0x%02X, seq=%d ***\n",
                       test_checksums[cs], test_seqs[sq]);
                WriteToLog("*** FOUND PERFECT COMBINATION! checksum=0x%02X, seq=%d ***\n",
                          test_checksums[cs], test_seqs[sq]);
                memcpy(data, temp, size);
                
                g_oldSendChecksum = original_checksum;
                // g_ucSendSeq = test_seqs[sq] + 1;
                g_ucSendSeq = (g_ucSendSeq + 1) % 256;
                return true;
            }
        }
    }

    if (best_diff <= 3) {
        printf("*** FOUND CLOSE MATCH! checksum=0x%02X, seq=%d, diff=%d ***\n",
               test_checksums[best_cs], test_seqs[best_sq], best_diff);
        WriteToLog("*** FOUND CLOSE MATCH! checksum=0x%02X, seq=%d, diff=%d ***\n",
                   test_checksums[best_cs], test_seqs[best_sq], best_diff);
        
        memcpy(data, best_result, size);
        
        if (best_diff <= 2) {
            g_oldSendChecksum = original_checksum;
            // g_ucSendSeq = test_seqs[best_sq] + 1;
            g_ucSendSeq = (g_ucSendSeq + 1) % 256;
        }
        return true;
    }

    return false;
}

bool DecryptReceived(char *data, int size)
{
    if (size < sizeof(HEADER))
        return false;

    unsigned char checksum = *((unsigned char *)(data + 3));
    int KeywordFlag = g_oldRecvChecksum % 2;
    unsigned char calculatedSum = 0;
    int pos = g_ucRecvSeq;

    for (int i = sizeof(HEADER); i < size; i++, pos++)
    {
        int rst = pos % 1024;
        unsigned char Trans = pKeyWord[rst][KeywordFlag];
        int mod = i & 0x3;

        if (mod == 0) data[i] = data[i] - (Trans << 2);
        if (mod == 1) data[i] = data[i] + (Trans >> 1);
        if (mod == 2) data[i] = data[i] - (Trans << 1);
        if (mod == 3) data[i] = data[i] + (Trans >> 2);

        calculatedSum += data[i];
    }

    g_oldRecvChecksum = checksum;
    g_ucRecvSeq++;

    return (calculatedSum == checksum);
}

int __stdcall HookedSend(unsigned int s, const char *buf, int len, int flags)
{
    // Enviar primero
    g_SendHook.Uninstall();
    int result = OriginalSend(s, buf, len, flags);
    g_SendHook.Install();

    if (result <= 0 || !g_ShowSendPackets)
        return result;

    // Procesar paquete
    if (len >= sizeof(HEADER) && len < 4096)
    {
        static char packet_buffer[4096];
        memcpy(packet_buffer, buf, len);
        
        // Detectar INITCODE
        if (len == 4) {
            unsigned int value = *(unsigned int *)packet_buffer;
            if (value == INITCODE) {
                printf("*** INITCODE MATCH! Resetting crypto state ***\n");
                WriteToLog("*** INITCODE MATCH! Resetting crypto state ***\n");
                g_oldSendChecksum = 0;
                g_ucSendSeq = 0;
                g_oldRecvChecksum = 0;
                g_ucRecvSeq = 0;
            }
            return result;
        }

        // Mostrar paquete encriptado
        PrintPacket("SEND", packet_buffer, len, false);

        // Intentar descifrar
        char decrypted[4096];
        memcpy(decrypted, packet_buffer, len);
        bool valid = DecryptSent(decrypted, len);

        if (valid) {
            PrintPacket("SEND", decrypted, len, true);
        } else {
            SetConsoleColor(FOREGROUND_YELLOW | FOREGROUND_INTENSITY);
            printf("*** DECRYPTION FAILED - CHECKSUM MISMATCH ***\n");
            WriteToLog("*** DECRYPTION FAILED - CHECKSUM MISMATCH ***\n");
            SetConsoleColor(FOREGROUND_WHITE);
        }
    }

    return result;
}

int __stdcall HookedRecv(unsigned int s, char *buf, int len, int flags)
{
    g_RecvHook.Uninstall();
    int result = OriginalRecv(s, buf, len, flags);
    g_RecvHook.Install();

    if (result > 0 && g_ShowRecvPackets)
    {
        // Detectar INITCODE
        if (result == 4 && *(unsigned int *)buf == INITCODE)
        {
            printf("*** INIT CODE DETECTED - CRYPTO RESET ***\n");
            WriteToLog("*** INIT CODE DETECTED - CRYPTO RESET ***\n");
            g_oldRecvChecksum = g_ucRecvSeq = 0;
            PrintPacket("RECV", buf, result, false);
            return result;
        }

        // Mostrar paquete recibido
        PrintPacket("RECV", buf, result, false);

        // Intentar descifrar si es un paquete válido
        if (result >= sizeof(HEADER) && result < 4096)
        {
            char decrypted[4096];
            memcpy(decrypted, buf, result);
            bool valid = DecryptReceived(decrypted, result);
            
            if (valid) {
                PrintPacket("RECV", decrypted, result, true);
            } else {
                SetConsoleColor(FOREGROUND_YELLOW | FOREGROUND_INTENSITY);
                printf("*** CHECKSUM MISMATCH ***\n");
                WriteToLog("*** CHECKSUM MISMATCH ***\n");
                SetConsoleColor(FOREGROUND_WHITE);
            }
        }
    }

    return result;
}

extern "C" BOOL WINAPI DllMain(HINSTANCE h, DWORD r, LPVOID p)
{
    if (r == DLL_PROCESS_ATTACH)
    {
        g_LogFile = fopen("htlauncher_traffic.log", "w");
        if (g_LogFile)
        {
            WriteToLog("=== HTLauncher Complete Traffic Log ===\n");
            WriteToLog("Logging ALL packets with full analysis\n\n");
        }

        Sleep(100);
        CreateConsole();

        if (g_ConsoleCreated)
        {
            printf("HTLauncher Complete Monitor iniciado!\n");
            printf("Log completo en: htlauncher_traffic.log\n");
            printf("PID: %lu\n", GetCurrentProcessId());
        }

        HMODULE ws2_32 = GetModuleHandleA("ws2_32.dll");
        if (ws2_32)
        {
            OriginalSend = (SendFunc)GetProcAddress(ws2_32, "send");
            OriginalRecv = (RecvFunc)GetProcAddress(ws2_32, "recv");

            if (OriginalSend && OriginalRecv)
            {
                g_SendHook.Init((void *)OriginalSend, (void *)HookedSend);
                g_RecvHook.Init((void *)OriginalRecv, (void *)HookedRecv);

                if (g_SendHook.Install() && g_RecvHook.Install())
                {
                    if (g_ConsoleCreated)
                    {
                        printf("Hooks instalados! Analizando todos los paquetes...\n");
                        printf("=====================================\n");
                    }
                    WriteToLog("Hooks instalados exitosamente\n");
                }
            }
        }
    }
    else if (r == DLL_PROCESS_DETACH)
    {
        g_SendHook.Uninstall();
        g_RecvHook.Uninstall();
        if (g_LogFile)
        {
            WriteToLog("\n=== Session End ===\n");
            fclose(g_LogFile);
        }
        if (g_ConsoleCreated)
        {
            printf("\nCerrando monitor...\n");
            Sleep(1000);
            FreeConsole();
        }
    }
    return TRUE;
}

extern "C" __declspec(dllexport) void TestFunc() {}